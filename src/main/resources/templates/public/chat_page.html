<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org" th:data-bs-theme="(${@securityService.hasUwUStage(2)})? 'pink':'light'">
<head>
    <link rel=stylesheet type="text/css" href="/public_static/css/bootstrap.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/public_static/js/bootstrap.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"> </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"> </script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- -->
    <script src="/public_static/infinity_war_config.js"> </script>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        article img {
            border-radius: 50%;
        }
        article {
            white-space: pre-line;
            overflow-wrap: break-word;
        }
        .username {
            text-decoration:none;
        }
    </style>

    <script>

        function sendMessage(event) {
            event.preventDefault();
            var csrf_token = document.getElementById('_csrf').value;
            channel_id = event.target.id.substring(4);

            var text = document.getElementById('text' + channel_id).value;
            stompClient.send("/app/message/" + room_id.value + '/' + channel_id, {'x-csrf-token':csrf_token},
                JSON.stringify({'text':text}));
            event.target.reset();
        }

        function unloadHandler() {
            stompClient.disconnect();
        }

        window.onbeforeunload = unloadHandler;
    </script>

    <!--<script th:utext = "${your_code}"></script> -->
</head>
<body>
<header th:replace="~{public/header :: |${@securityService.getAccess()}_header|}"></header>
<main class="container">
    <input type="hidden" name = "username" th:value="${@securityService.getUsername()}" id = "username"/>
    <input type="hidden" name = "room_id" th:value="${room_id}" id = "room_id"/>
    <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" id = "_csrf"/>

    <div class="row">
        <div class="col-12" id="app">
            <nav class="navbar navbar-expand-sm bg-color2 navbar-light p-2" style="z-index:999; position:sticky; top:80px;">

                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#chat_menu"
                        aria-controls="chat_menu" aria-expanded="false" aria-label="Toggle chat menu">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <div id = "chat_menu" class="row collapse navbar-collapse justify-content-between">
                    <div class="col-auto">
                        <a th:href="'/user/exit_room/' + ${room_id}"><button class="btn btn-outline-secondary" type="button" id="quit_button">выйти</button></a>
                        <button v-if = "status === 'not started'" th:if="${host}==true" class="btn btn-outline-secondary" type="button" id="start_button" @click="submit_start_room">начать</button>
                        <button v-if = "status === 'started'" th:if="${host}==true" class="btn btn-outline-secondary" type="button" id="skip_button" @click="processing_stage">пропустить</button>
                        <div v-if = "status !== 'not started'" th:if="${host}==true" class="dropdown" style="display:inline-block;">
                            <button class="btn btn-secondary dropdown-toggle" data-bs-auto-close="false" type="button" id="switchPlayerButton"
                                    data-bs-toggle="dropdown" aria-expanded="false">
                                <img src="/public_static/icons/people.svg" width="30" height="30">
                            </button>
                            <div class="dropdown-menu p-2" aria-labelledby="switchPlayerButton">
                                <form @submit="change_player">
                                    <label>
                                        <input class="form-control" type="number" name="player_index" id = "player_index">
                                    </label>
                                    <input class="mt-2 btn btn-primary" type="submit">
                                </form>
                            </div>
                        </div>
                        <div><span id="current_stage" style="font-size:1.25rem;"></span></div>
                        <div><span id="time_until_new_stage" style="font-size:1.25rem;"></span></div>
                    </div>

                    <div class="col-auto">
                        <nav-pills :channels="channels" :polls="polls" :status="status"
                                   :active_tab="active_tab" @changeactivetab = "change_active_tab"></nav-pills>
                    </div>
                </div>
            </nav>

            <tab-content :channels="channels"  :polls = "polls" :active_tab = "active_tab"
                         :status = "status" :players = "players"
                         :channel-read-mask = "channelReadMask" :channel-write-mask = "channelWriteMask"
                         :poll-vote-mask = "pollVoteMask"></tab-content>
        </div>
    </div>
    <script>

    const app = Vue.createApp({

        data() {
            return {channels: [], polls: [], players: [], status: null, active_tab: null,
                channelReadMask: 0, channelWriteMask: 0, pollVoteMask: 0};
        },
        methods: {

            finish_state: function (state) {
                this.stateChannels = state.channels;
            },

            convert_state: function (state) {
                let cnt = 0;
                for (const index of state.polls.keys()) {
                    state.polls[index].lindex = cnt++;
                }

                for (const index of state.channels.keys()) {
                    state.channels[index].cindex = this.cindexMap.get(state.channels[index].name);
                }

                let tmp_channels = structuredClone(this.stateChannels);
                for (const index of state.channels.keys()) {

                    let cindex = state.channels[index].cindex;
                    let curr_channel = state.channels[index];

                    if (curr_channel.read_mask !== undefined) {
                        tmp_channels[cindex].read_mask = curr_channel.read_mask;
                    }
                    if (curr_channel.anon_read_mask !== undefined) {
                        tmp_channels[cindex].anon_read_mask = curr_channel.anon_read_mask;
                    }
                    if (curr_channel.read_real_username_mask !== undefined) {
                        tmp_channels[cindex].read_real_username_mask = curr_channel.read_real_username_mask;
                    }
                    if (curr_channel.write_mask !== undefined) {
                        tmp_channels[cindex].write_mask = curr_channel.write_mask;
                    }
                    if (curr_channel.anon_write_mask !== undefined) {
                        tmp_channels[cindex].anon_write_mask = curr_channel.anon_write_mask;
                    }
                }
                state.channels = tmp_channels;

                state.characters = [];
                for (let i = 0; i < this.playerCount; i++) {
                    let player_mask = 1 << i;
                    let character_state = {
                        "channelReadMask": 0, "channelAnonReadMask": 0, "channelXRayReadMask": 0,
                        "channelWriteMask": 0, "channelAnonWriteMask": 0,
                        "pollVoteMask": 0, "pollObserveMask": 0, "pindex": i
                    };

                    if (state.names[i] !== undefined) {
                        character_state.name = state.names[i];
                    }

                    for (const channel of state.channels) {
                        if ((channel.read_mask & player_mask) !== 0) {
                            character_state.channelReadMask |= 1 << channel.cindex;
                        }
                        if ((channel.anon_read_mask & player_mask) !== 0) {
                            character_state.channelAnonReadMask |= 1 << channel.cindex;
                        }
                        if ((channel.read_real_username_mask & player_mask) !== 0) {
                            character_state.channelXRayReadMask |= 1 << channel.cindex;
                        }
                        if ((channel.write_mask & player_mask) !== 0) {
                            character_state.channelWriteMask |= 1 << channel.cindex;
                        }
                        if ((channel.anon_write_mask & player_mask) !== 0) {
                            character_state.channelAnonWriteMask |= 1 << channel.cindex;
                        }
                    }

                    for (const poll of state.polls) {
                        if ((poll.mask_voters & player_mask) !== 0) {
                            character_state.pollVoteMask |= 1 << poll.lindex;
                        }
                        if ((poll.mask_observers & player_mask) !== 0) {
                            character_state.pollObserveMask |= 1 << poll.lindex;
                        }
                    }

                    state.characters.push(character_state);
                }

                return state;
            },

            submit_start_room: function() {
                let csrf = document.getElementById('_csrf').value;
                let room_id = document.getElementById('room_id').value;
                let self = this;

                fetch('/user/processing_start_room/' + room_id, {
                    method: 'post',
                    headers: {
                        "X-CSRF-TOKEN" : csrf,
                    }
                }).then( (response) => {
                    if (response.status !== 200) {
                        console.log("Can't start room. Status Code: " + response.status);
                        return;
                    }
                    response.json().then(function(data) {
                        self.playerCount = data;
                        let initial_state = initialize_room(data);

                        self.cindexMap = new Map();
                        let cnt = 2;
                        for (const index of initial_state.channels.keys()) {
                            if (initial_state.channels[index].name === 'лобби')
                                self.cindexMap.set('лобби', 0)
                            else if (initial_state.channels[index].name === 'газета')
                                self.cindexMap.set('газета', 1)
                            else
                                self.cindexMap.set(initial_state.channels[index].name, cnt++);
                        }

                        self.stateChannels = [];
                        for (const channel of initial_state.channels) {
                            self.stateChannels[self.cindexMap.get(channel.name)] = {
                                "read_mask": 0, "anon_read_mask": 0, "read_real_username_mask": 0,
                                "write_mask": 0, "anon_write_mask": 0,
                                "name": channel.name, "cindex": self.cindexMap.get(channel.name)
                            };
                        }

                        initial_state = self.convert_state(initial_state);

                        fetch('/user/start_room/' + room_id, {
                            method: 'post',
                            headers: {
                                "X-CSRF-TOKEN" : csrf,
                                "Content-Type" : "application/json; charset=utf-8"
                            },
                            body: JSON.stringify(initial_state)
                        }).then( (response) => {
                            if (response.status !== 200) {
                                console.log("Can't start room. Status Code: " + response.status);
                                return;
                            }

                            self.finish_state(initial_state);

                            window.nextStageTimer = setTimeout(function () {
                                self.processing_stage();
                            }, initial_state.duration * 1000);
                        });
                    });
                });
            },
            processing_stage: function() {

                clearTimeout(window.nextStageTimer);
                window.nextStageTimer = null;

                let csrf = document.getElementById('_csrf').value;
                let room_id = document.getElementById('room_id').value;
                let self = this;

                fetch('/user/get_data_for_processing/' + room_id, {
                    headers: {
                        'Accept': 'application/json'
                    }
                }).then(
                    function(response) {
                        if (response.status !== 200) {
                            console.log("Can't load results of the previous stage. Status Code: " + response.status);
                            return;
                        }

                        response.json().then(function(data) {
                            let new_state = update_state(data);

                            new_state = self.convert_state(new_state);

                            fetch('/user/update_room_state/' + room_id, {
                                method: 'post',
                                headers: {
                                    "X-CSRF-TOKEN" : csrf,
                                    "Content-Type" : "application/json; charset=utf-8"
                                },
                                body: JSON.stringify(new_state)
                            }).then( (response) => {
                                if (response.status !== 200) {
                                    console.log("Can't send state of the current stage. Status Code: " + response.status);
                                    return;
                                }

                                self.finish_state(new_state);

                                window.nextStageTimer = setTimeout(function () {
                                    self.processing_stage();
                                }, new_state.duration * 1000);
                            });
                        });
                    }
                );
            },

            add_message: function (stage, message) {
                if (!window.messageIds.has(message.id)) {
                    window.messageIds.add(message.id);
                    stage.messages.push(message);
                    stage.count++;
                }
            },

            update_ui: function (status) {
                let self = this;

                if (status.body === 'initialization' || status.body === 'processing') {
                    time_until_new_stage.innerHTML = "Идет обработка...";
                    return;
                }

                if (status.body === 'finished' || status.body === 'closed') {
                    time_until_new_stage.innerHTML = "Игра окончена.";
                }

                fetch('/user/status_room/' + room_id.value, {
                    headers: {
                        'Accept': 'application/json'
                    }
                }).then(
                    function (response) {
                        if (response.status !== 200) {
                            console.log("Can't load messages. Status Code: " + response.status);
                            return;
                        }
                        response.json().then(function (data) {

                            if (window.intervalID != null) {
                                clearInterval(window.intervalID);
                                window.intervalID = null;
                            }

                            if (data.status === "started") {

                                let time_until_new_stage = document.getElementById("time_until_new_stage");

                                let finish = data.finish_stage * 1000;
                                window.intervalID = setInterval(function () {
                                    let res = (finish - Date.now()) / 1000;

                                    if (res < 0) {
                                        time_until_new_stage.innerHTML = "Осталось 0 секунд";
                                        clearInterval(window.intervalID);
                                        return;
                                    }

                                    time_until_new_stage.innerHTML = "До конца сталось " + Math.round(res) + " секунд";
                                }, 1000);

                                current_stage.innerHTML = "Сейчас " + data.stage;
                            }

                            let has_active_tab = false;
                            for (const channel of data.channels) {
                                if (self.active_tab === channel.name) {
                                    has_active_tab = true;
                                    break;
                                }
                            }
                            for (const poll of data.polls) {
                                if (self.active_tab === poll.name) {
                                    has_active_tab = true;
                                    break;
                                }
                            }

                            if (!has_active_tab) {
                                if (data.status === "not started") {
                                    self.active_tab = "лобби";
                                } else {
                                    self.active_tab = "газета";
                                }
                            }

                            self.channelReadMask = data.channelReadMask;
                            self.channelWriteMask = data.channelWriteMask;
                            self.pollVoteMask = data.pollVoteMask;
                            self.polls = data.polls;
                            self.status = data.status;

                            if (data.status !== "not started" && window.player_subscription != null) {
                                window.player_subscription.unsubscribe();
                                window.player_subscription = null;
                            }

                            let new_subscriptions = new Map();
                            for (const channel of data.channels) {
                                if (window.subscriptions.has(channel.channel_id)) {
                                    new_subscriptions.set(channel.channel_id,
                                        window.subscriptions.get(channel.channel_id))

                                    window.subscriptions.delete(channel.channel_id);
                                }
                            }

                            for (const subscription of window.subscriptions) {
                                let index = self.channels.findIndex(x => (x.channel_id === subscription[0]));
                                if (index !== -1)
                                    self.channels.splice(index, 1);

                                subscription[1].unsubscribe();
                            }

                            window.subscriptions = new_subscriptions;

                            for (let channel of data.channels) {
                                if (!window.subscriptions.has(channel.channel_id)) {
                                    self.channels.push(channel);
                                }
                            }

                            for (const index of self.channels.keys()) {

                                let channel = self.channels[index];

                                if (window.subscriptions.has(channel.channel_id)) {
                                    if (channel.name === "газета") {
                                        self.add_message(channel.stages[0], data.newspaperMessage);
                                    }

                                    if (channel.stages.length !== 0 && channel.name !== "газета" &&
                                        channel.stages[channel.stages.length - 1].count === 0) {
                                        channel.stages.splice(channel.stages.length - 1, 1);
                                    }

                                    if (channel.name !== "газета")
                                        channel.stages.push({
                                            stage_name: data.stage,
                                            stage_id: data.stage_id,
                                            count : 0,
                                            messages: [],
                                            loaded: true
                                        });

                                    continue;
                                }

                                channel["stages"] = [];

                                if ((self.channelReadMask & (1 << channel.cindex)) === 0)
                                    continue;

                                let subscription = stompClient.subscribe('/topic/messages/' + room_id.value + '/' + channel.channel_id,
                                    function (messageOutput) {
                                        let message_id = messageOutput.body;
                                        fetch('/public/chat/get_message/' + message_id, {
                                            headers: {
                                                'Accept': 'application/json'
                                            }
                                        }).then(
                                            function (response) {
                                                if (response.status !== 200) {
                                                    console.log("Can't load message. Status Code: " + response.status);
                                                    return;
                                                }
                                                response.json().then(function (data) {
                                                    self.add_message(channel.stages[channel.stages.length - 1], data);
                                                });
                                            }
                                        );
                                    }
                                );

                                window.subscriptions.set(channel.channel_id, subscription);

                                fetch('/public/chat/get_messages/' + room_id.value + '/' + channel.channel_id, {
                                    headers: {
                                        'Accept': 'application/json'
                                    }
                                }).then(
                                    function (response) {
                                        if (response.status !== 200) {
                                            console.log("Can't load messages. Status Code: " + response.status);
                                            return;
                                        }
                                        response.json().then(function (data) {
                                            channel.stages = [];

                                            for (const stage of data) {

                                                let new_stage = {
                                                    stage_name: stage.stage_name,
                                                    stage_id: stage.stage_id,
                                                    count: stage.count,
                                                    messages: [],
                                                    loaded: stage.loaded
                                                };

                                                for (const message of stage.messages) {
                                                    self.add_message(new_stage, message)
                                                }

                                                channel.stages.push(new_stage);
                                            }
                                        });
                                    }
                                );
                            }

                            if (data.status === 'not started' && window.player_subscription == null) {

                                window.player_subscription = stompClient.subscribe('/topic/players/' + room_id.value,
                                    function (data) { self.players = JSON.parse(data.body);
                                });

                                fetch('/public/room/get_players/' + room_id.value, {
                                    headers: {
                                        'Accept': 'application/json'
                                    }
                                }).then(
                                    function (response) {

                                        if (response.status !== 200) {
                                            console.log("Can't load players. Status Code: " + response.status);
                                            return;
                                        }
                                        response.json().then(function (players) {
                                            self.players = players;
                                        });
                                    }
                                );
                            }
                        });
                    });
            },
            connect: function () {
                let socket = new SockJS('/public/stomp/chat');
                stompClient = Stomp.over(socket);
                let self = this;
                stompClient.connect({},
                    function (frame) {
                        self.update_ui({body: "not started"});
                        stompClient.subscribe('/topic/room_status/' + room_id.value, self.update_ui);
                    },
                    function (error) {
                    });
            },

            change_player: function (event) {
                event.preventDefault();
                let self = this;

                fetch('/user/change_player/' + room_id.value + "?index=" + player_index.value, {
                    method: 'post',
                    headers: {
                        "X-CSRF-TOKEN" : _csrf.value,
                    }
                }).then( (response) => {
                    if (response.status !== 200) {
                        console.log("Can't start room. Status Code: " + response.status);
                        return;
                    }

                    self.channels = [];
                    self.poll = [];
                    self.active_tab = -1;
                    self.status = null;
                    self.players = [];

                    for (const subscription of window.subscriptions.values()) {
                        subscription.unsubscribe();
                    }
                    if (window.player_subscription != null)
                        window.player_subscription.unsubscribe();

                    window.player_subscription = null;
                    window.subscriptions = new Map();
                    window.messageIds = new Set();
                    clearInterval(window.intervalID);
                    window.intervalID = null;

                    self.update_ui({body:"started"});
                });
            },
            change_active_tab: function (new_active_tab) {
                this.active_tab = new_active_tab;
                //console.log("new active tab:" + new_active_tab);
            }
        },
        mounted() {
            window.subscriptions = new Map();
            window.player_subscription = null;
            window.intervalID = null;
            window.messageIds = new Set();
            this.connect();
        }
    });

    app.component("nav-pill-channel", {
        props: ["channel_id", "channel_name", "active_tab"],

        template: `
          <li class="nav-item" role="presentation">
            <button :class="'nav-link ' + ((channel_name === active_tab) ? 'active' : '')"
                    :id="channel_id + '-tab'" data-bs-toggle="pill" type="button" role="tab"
                    :aria-controls="'pills-' + channel_id" aria-selected="true"
                    @click = "$parent.$emit('changeactivetab', channel_name)">{{ channel_name }}
            </button>
          </li>
        `
    });

    app.component("nav-pill-poll", {
        props: ["poll_id", "poll_name", "active_tab"],

        template: `
          <li class="nav-item" role="presentation">
            <button :class="'nav-link ' + ((poll_name === active_tab) ? 'active' : '')"
                    :id="poll_id + '-poll-tab'" data-bs-toggle="pill" type="button" role="tab"
                    :aria-controls="'pills-poll-' + poll_id" aria-selected="true"
                    @click = "$parent.$emit('changeactivetab', poll_name)">{{ poll_name }}
            </button>
          </li>
        `
    });

    app.component("nav-pill-players", {
        props: ["active_tab"],

        template: `
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="pills-players-tab" data-bs-toggle="pill"
                        type="button" role="tab" aria-controls="pills-players" aria-selected="false"
                        @click = "$parent.$emit('changeactivetab', 'игроки')">игроки
                </button>
              </li>
            `
    });

    app.component("nav-pills", {
        props: ["channels", "polls", "status", "active_tab"],
        template: `
          <ul class="nav nav-pills" id="pills-tab" role="tablist">
            <nav-pill-channel v-for="channel in channels"
                              :channel_id="channel.channel_id"
                              :channel_name="channel.name"
                              :active_tab="active_tab"
                              :key="channel.channel_id">
            </nav-pill-channel>
            <nav-pill-poll v-for="poll in polls"
                           :poll_id="poll.poll_id"
                           :poll_name="poll.name"
                           :active_tab = "active_tab"
                           :key="poll.poll_id">
            </nav-pill-poll>
            <nav-pill-players v-if="status==='not started'" :active_tab="active_tab"></nav-pill-players>
          </ul>
        `
    });

    app.component("channel-comment", {
        props: ["message"],
        template: `
          <article v-if = "message.username != null" class="row py-2">
            <a class="col-auto" target="_blank" :href="'/public/profile/' + message.username" style="position:relative;">
              <img :src="'/public/photo/' + message.username" width="60" height="60"
                   :alt="'аватарка пользователя' + message.username">
              <img src="/public_static/catmaid.jpg" width="60" height="60" alt="кошкогорничная"
                   :style="'position: absolute; z-index: 99; left:calc(var(--bs-gutter-x) * .5); border-radius:50%; opacity:' + message.opacity + ';'">
            </a>
            <div class="col-sm col-xs-12">
              <div>
                <b><a class="username" target="_blank" :href="'/public/profile/' + message.username"
                      :style="(message.username_color == null) ? '' : ('color:' + message.username_color + ';')">
                  {{message.username + ((message.alias == null || message.alias === message.username) ? "" : ("(" + message.alias + ")"))}}</a></b>
              </div>
              <div>{{message.text}}</div>
            </div>
          </article>
          <article v-if = "message.username == null" class="row py-2">
            <span class="col-auto">
              <img :src="(message.alias === '???')? '/public_static/who_i_am.jpg' :
              ('/public/photo/' + (message.alias.charCodeAt(0) + 37 * message.alias.length) % 27)"
                   width="60" height="60" :alt="'маска пользователя' + message.alias">
            </span>
            <div class="col-sm col-xs-12">
              <div>
                <b :style="(message.username_color == null)? '' : ('color:' + message.username_color + ';')">{{message.alias}}</b>
              </div>
              <div>{{message.text}}</div>
            </div>
          </article>
        `
    });

    app.component("stage-channel", {
        props: ["channel_id", "stage"],
        methods: {

            add_message: function (stage, message) {
                if (!window.messageIds.has(message.id)) {
                    window.messageIds.add(message.id);
                    stage.messages.push(message);
                    stage.count++;
                }
            },

            load_stage_channel_messages: function (event) {
                if (this.stage.loaded === true) {

                    if (event.target.getAttribute("aria-expanded") === "true") {
                        event.target.setAttribute("aria-expanded", "false");
                        let collapse = document.getElementById(event.target.getAttribute("aria-controls"));
                        collapse.classList.remove('show');
                    } else {
                        event.target.setAttribute("aria-expanded", "true");
                        let collapse = document.getElementById(event.target.getAttribute("aria-controls"));
                        collapse.classList.add('show');
                    }

                    return;
                }

                let self = this;
                event.target.classList.add("disabled");

                fetch('/public/chat/get_stage_messages/' + this.channel_id + '/' + this.stage.stage_id, {
                    headers: {
                        'Accept': 'application/json'
                    }
                }).then(
                    function (response) {

                        if (response.status !== 200) {
                            console.log("Can't load messages. Status Code: " + response.status);
                            event.target.classList.remove("disabled");
                            return;
                        }

                        response.json().then(function (data) {
                            self.stage.loaded = true;
                            event.target.classList.remove("disabled");

                            for (const message of data) {
                                self.add_message(self.stage, message)
                            }
                        });
                    }
                );
            }
        },
        template: `
            <button class="btn btn-secondary" type="button" data-bs-toggle="collapse"
                    aria-expanded="true" :aria-controls="'collapse-' + channel_id + '-' + stage.stage_id"
                    style="width: 100%;" @click = "load_stage_channel_messages">
              {{ stage.stage_name}}
            </button>
            <div class="collapse show" :id="'collapse-' + channel_id + '-' + stage.stage_id">
              <div class = "col-12" :id="'articles' + channel_id">
                <channel-comment v-for="message in stage.messages" :message = "message" :key="message.id"></channel-comment>
              </div>
            </div>
        `
    });

    app.component("tab-panel-channel", {
        props: ["channel_id", "active_tab", "channel_name", "can_read", "can_write", "stages"],

        template: `
          <div :class="'tab-pane fade ' + ((active_tab === channel_name) ? 'show active' : '')"
               :id="'pills-' + channel_id" role="tabpanel" :aria-labelledby="channel_id + '-tab'">
            <div class="row">
              <div v-if="can_read" class = "col-12" :id="'articles' + channel_id">
                <stage-channel v-for = "stage in stages" :stage="stage" :channel_id="channel_id" :key="channel_id + '-' + stage.stage_id">
                </stage-channel>
              </div>
              <div v-if="can_write" class = "col-12">
                <form :id="'form' + channel_id" onsubmit="sendMessage(event)" class="row py-2">
                  <input type="hidden" name = "channel" :value="channel_id"/>
                  <div class="col-11">
                    <textarea class="form-control" rows="3"
                              name="text" :id="'text' + channel_id"></textarea>
                  </div>
                  <div class="col-1 px-0">
                    <button class="px-0">
                      <img src="/public_static/icons/send.svg" width="30" height="30" alt="кнопка отправить">
                    </button>
                  </div>
                </form>
              </div>
            </div>
          </div>
        `
    });

    app.component("vote-button", {
        props: ["poll_id", "candidate_name", "candidate_index", "selection"],

        template: `
          <label class="m-1">
            <input type="button" class="btn btn-secondary"
                   :class="(selection.has(candidate_name))? 'active' : ''"
                   @click="$emit('change-vote', candidate_name)"
                   :value = "candidate_name">
          </label>
        `
    });

    app.component("tab-panel-poll", {
        props: ["poll_id", "poll_name", "description", "max_selection", "min_selection", "candidates", "can_vote", "active_tab"],

        data() { return{
            selected_candidate_name : null,
            selected_candidate_index : null,
            voted: false,
            selection: new Set()
        }},

        methods: {
            sendVote: function (event) {
                event.preventDefault();

                let selection_url = []
                for (const candidate of this.selection) {
                    if (this.candidates[candidate] !== undefined) {
                        selection_url.push("candidates=" + this.candidates[candidate]);
                    }
                }

                let self = this;

                fetch('/user/vote/' + this.poll_id + '?' + selection_url.join("&"), {
                    method: 'post',
                    headers: {
                        "X-CSRF-TOKEN": document.getElementById('_csrf').value,
                    },
                }).then((response) => {
                    if (response.status !== 200) {
                        console.log("Can't vote. Status Code: " + response.status);
                    } else {
                        self.voted = true;
                    }
                });
            },


            changeVote: function (candidate_name) {

                console.log("vote change");
                console.log(candidate_name);
                console.log(this.voted);

                if (this.selection.has(candidate_name)) {
                    this.selection.delete(candidate_name);
                } else {
                    if (this.selection.size !== this.max_selection)
                        this.selection.add(candidate_name);
                }
            }
        },

        template: `
          <div :class="'tab-pane fade ' + ((active_tab === poll_name) ? 'show active' : '')"
               :id="'pills-poll-' + poll_id" role="tabpanel" :aria-labelledby="poll_id + '-poll-tab'">

            <form class="row" @submit="sendVote" :id="'form-poll-' + poll_id">
              <span style="display: block; font-size: 1.25rem; white-space:pre-line;" class="m-2">{{description}}</span>
              <div class="col-12" :id="'candidates-poll-' + poll_id">
                <vote-button v-for = "(candidate_index, candidate_name) in candidates"
                             :poll_id="poll_id"
                             :candidate_index="candidate_index"
                             :candidate_name="candidate_name"
                             :selection="selection"
                             @change-vote = "changeVote"></vote-button>
              </div>
              <div class="col-auto mt-4">
                <button class="btn btn-primary submit-vote-button"
                        :class="(can_vote && !voted && this.selection.size >= this.min_selection && this.selection.size <= this.max_selection)? '' : 'disabled'">Голосовать</button>
              </div>
            </form>
          </div>
        `
    });

    app.component("player-info", {
        props: ["player"],

        template: `
            <li class="row py-2">
                <a class="col-auto" :href="'/public/profile/' + player.login" style="position:relative;">
                    <img :src="'/public/photo/' + player.login" width="60" height="60"
                        :alt="'аватарка пользователя ' + player.login" style="border-radius:50%;">
                    <img src="/public_static/catmaid.jpg" width="60" height="60"
                        alt="кошкогорничная" :style="'position: absolute; z-index: 99; ' +
                         'left:calc(var(--bs-gutter-x) * .5); border-radius:50%; opacity: ' + player.degreeUwU + ';'">
                </a>
                <div class="col-sm col-xs-12">
                    <b><a class="username" :href="'/public/profile/' + player.login">{{player.login}}</a></b>
                </div>
            </li>
        `
    });

    app.component("tab-panel-players", {
        props: ["players", "active_tab"],

        template: `
            <div :class="'tab-pane fade ' + ((active_tab === 'игроки') ? 'show active' : '')"
                 id="pills-players" role="tabpanel" aria-labelledby="pills-players-tab">
                <div class = "col-12" id="players">
                    <player-info v-for="player in players" :player="player"></player-info>
                </div>
            </div>
        `
    });

    app.component("tab-content", {
        props: ["channels", "polls", "players", "active_tab", "status",
            "channelReadMask", "channelWriteMask", "pollVoteMask"],

        template: `
          <div class="tab-content" id="pills-tabContent">
            <tab-panel-channel v-for = "channel in channels"
                       :channel_id = "channel.channel_id"
                       :active_tab = "active_tab"
                       :channel_name = "channel.name"
                       :can_read = "(channelReadMask & (1 << channel.cindex)) !== 0"
                               :can_write = "(channelWriteMask & (1 << channel.cindex)) !== 0"
                               :stages = "channel.stages" :key="channel.channel_id">
            </tab-panel-channel>
            <tab-panel-poll v-for = "poll in polls"
                            :poll_id = "poll.poll_id"
                            :poll_name = "poll.name"
                            :description = "poll.description"
                            :candidates = "poll.candidates"
                            :max_selection = "poll.maxSelection"
                            :min_selection = "poll.minSelection"
                            :active_tab = "active_tab"
                            :can_vote = "(pollVoteMask & (1 << poll.lindex)) !== 0"
                            :key = "poll.poll_id">
            </tab-panel-poll>
            <tab-panel-players v-if="status==='not started'" :players="players" :active_tab="active_tab"></tab-panel-players>
          </div>
        `
    });

    app.mount('#app');
    </script>
</main>
<footer th:replace="~{public/footer :: footer}"></footer>
</body>
</html>